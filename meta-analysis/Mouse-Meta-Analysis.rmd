---
title: "Mouse-Meta-Analysis"
knit: (function(input_file, encoding) {
  out_dir <- 'docs';
  rmarkdown::render(input_file,
 encoding=encoding,
 output_file=file.path(dirname(input_file), out_dir, 'index.html'))})
author: "Sidhant Puntambekar"
date: "7/14/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=TRUE)
knitr::opts_chunk$set(echo = TRUE)
```

## Mouse meta-analysis

This file contains the meta-analysis of the mouseAtlas.rds generated by combining reference matrices from a variety of scRNA-seq datasets from across NCBI GEO and Tabula Muris. 

First, the necessary libraries will be loaded in. They are dplyr (standard dataframe library), Seurat (create Seurat object), patchwork (ggplot library), clustifyr (clustifyr functions), tidyverse (collection of R data science packages), here (reproducibility of results), and clustree (visualizing clustering in hierarchical structure)

```{r Load libraries}
library(dplyr)
library(Seurat)
library(patchwork)
library(clustifyr)
library(tidyverse)
library(here)
library(clustree)
```

## Load Mouse Atlas

The mouse atlas will now be loaded into the local R data section. This will be accomplished with the here library establishing the root of the project and then loading in the mouseAtlas.rds file into the mouseAtlas matrix object. A Seurat object will then be created in order to perform single cell analysis on the mouse atlas. 

```{r Create Seurat Object}
proj_dir <- here()
mouseAtlas <- readRDS(file.path(proj_dir, "atlas", "musMusculus", "mouseAtlas.rds"))

mouseMetaAnalysis <- CreateSeuratObject(counts = mouseAtlas, project = "Mouse-Meta-Analysis", min.cells = 0, min.features = 0)
gc()

#Normalize Data
mouseMetaAnalysis <- NormalizeData(mouseMetaAnalysis, normalization.method = "LogNormalize", scale.factor = 10000)
```

## Preprocessing Workflow

Following the creation of the Seurat object, the standard workflow for annotating cell types will be followed. First we will filter out cells that do not meet any of the standard QC metrics, data normalization and scaling. First we will filter out genes that contain mitochondrial contamination using a percentage feature set and scanning for the ```^mt-``` pattern. All of the lines following help to visualize the QC metrics we are filtering out by (nCounts, nFeatures, percent.mt)

```{r preprocessing, fig.width=15}
#Preprocessing workflow
mouseMetaAnalysis[["percent.mt"]] <- PercentageFeatureSet(mouseMetaAnalysis, pattern = "^mt-")
VlnPlot(mouseMetaAnalysis, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
plot1 <- FeatureScatter(mouseMetaAnalysis, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(mouseMetaAnalysis, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2
```

## Find Variable Features for PCA

In order to run principal component analysis on the data, cells with high gene expression variability compared to the rest of the data will need to be determined. This will help highlight biological signal of cells in further downstream analysis with PCA and uniform manifold approximation and projection (UMAP). The highly variable genes can also be plotted on a variable feature plot showing standard variance against average gene expression.  

```{r Find Variable Features, fig.width=15}
#Find Variable Features for PCA
mouseMetaAnalysis <- FindVariableFeatures(mouseMetaAnalysis, selection.method = "mean.var.plot", nfeatures = 2000)
top10 <- head(VariableFeatures(mouseMetaAnalysis), 10)
plot1 <- VariableFeaturePlot(mouseMetaAnalysis)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot1 + plot2
```


## Linear dimension reduction and PCA

Once the variable features have been highlighted, the data can now be reduced into two dimensions from a large number of dimensions through principal component analysis. First, the data must be "scaled" in which a linear transformation shifts the expression of each gene so that the mean expression across cells is zero and that the variance across each cell is one. This should help highly expressed genes not to dominate the data. 

Next, PCA will occur which will scale the data down into two dimensions. The results can be visualized through heat maps and scatter plots. 

```{r Linear dimension reduction and PCA}
all.genes <- rownames(mouseMetaAnalysis)
mouseMetaAnalysis <- ScaleData(mouseMetaAnalysis, features = all.genes)
mouseMetaAnalysis <- RunPCA(mouseMetaAnalysis,
                            features = all.genes,
                            npcs = ncol(mouseMetaAnalysis) - 1)
print(mouseMetaAnalysis[["pca"]], dims = 1:5, nfeatures = 5)
VizDimLoadings(mouseMetaAnalysis, dims = 1:2, reduction = "pca")
DimPlot(mouseMetaAnalysis, reduction = "pca")
DimHeatmap(mouseMetaAnalysis, dims = 1, cells = 500, balanced = TRUE)
DimHeatmap(mouseMetaAnalysis, dims = 1:15, cells = 500, balanced = TRUE)
```

## Determine dimensionality

Following PCA, the number of PCs or clusters that are needed to fully represent the data on a UMAP need to be determined. Many scRNA-seq datasets contain technical noise in the various clusters and the number of clusters needed to represent the dataset must be determined. In this analysis, jack straw plots and a slightly more heuristic elbow plot will be used to determine the accurate number of clusters for UMAP analysis. 

```{r Determine dimensionality}
#Determine dimensionality
mouseMetaAnalysis <- JackStraw(mouseMetaAnalysis, num.replicate = 100)
mouseMetaAnalysis <- ScoreJackStraw(mouseMetaAnalysis, dims = 1:20)
JackStrawPlot(mouseMetaAnalysis, dims = 1:15)
ElbowPlot(mouseMetaAnalysis)
```

## Clustering and unannotated UMAP

Based on the jack straw and elbow plots, the number of clusters to accurately represent the data is around 20 to 30 clusters. We will generate clusters with a resolution of 5.0 to accomplish this. It is important to note that changing the resolution value will drastically change the number of clusters produced by the ```FindClusters()``` method. 

```{r Clustering and unannotated UMAP}
#Clustering
mouseMetaAnalysis <- FindNeighbors(mouseMetaAnalysis, dims = 1:10)
mouseMetaAnalysis <- FindClusters(mouseMetaAnalysis, resolution = 5.0, verbose = TRUE)
head(Idents(mouseMetaAnalysis), 5)

#Create unannotated UMAP
mouseMetaAnalysis <- RunUMAP(mouseMetaAnalysis, dims = 1:10)
DimPlot(mouseMetaAnalysis, reduction = "umap")
```

## Cluster biomarkers

In order to determine which genes are being expressed in the UMAP, biomarkers must be clustered through the use of the ```FindAllMarkers()``` function. This function automates the process across all clusters and helps to expedite the biomarker selection process. A number of visualization steps can be taken here, but in this analysis, a heat map of the top 10 clusters with each expression of each biomarker will be shown. 

```{r cluster biomarkers}
#Cluster biomarkers
cluster1.markers <- FindMarkers(mouseMetaAnalysis, ident.1 = 1, min.pct = 0.25)
head(cluster1.markers, n = 5)
cluster5.markers <- FindMarkers(mouseMetaAnalysis, ident.1 = 5, ident.2 = c(0,3), min.pct = 0.25)
head(cluster5.markers, n = 5)
mouseMetaAnalysis.markers <- FindAllMarkers(mouseMetaAnalysis, only.pos = TRUE, min.pct = 0.1, logfc.threshold = 0.25)
mouseMetaAnalysis.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_logFC)
cluster1.markers <- FindMarkers(mouseMetaAnalysis, ident.1 = 0, logfc.threshold = 0.25, test.use = "roc", only.pos = TRUE)
top10 <- mouseMetaAnalysis.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC) #Create top 10 markers for each cluster
DoHeatmap(mouseMetaAnalysis, features = top10$gene) + NoLegend() #Create heat map of biomarkers for all top 17 clusters
```

## Annotate UMAP

Annotating the previously generated UMAP can clarify cell types present in the UMAP and allows for a better analysis of which cells are located where on the UMAP. Here, the column names in the ```mouseAtlas.rds``` file are the cell types so we can rename the identities of the cells on the UMAP with the correct cell names. ```HoverLocator``` and a UMAP grouped by study can also be helpful to highlight where each cell in the atlas originates. 

```{r annotate UMAP}
#Assign cell types/Annotate UMAP
new.cluster.ids <- colnames(mouseAtlas)
names(new.cluster.ids) <- levels(mouseMetaAnalysis)
mouseMetaAnalysis <- RenameIdents(mouseMetaAnalysis, new.cluster.ids)
AnnotatedUMAP <- DimPlot(mouseMetaAnalysis, reduction = "umap", label = FALSE, pt.size = 0.5) 
HoverLocator(plot = AnnotatedUMAP, information = FetchData(mouseMetaAnalysis, vars = c("seurat_clusters")))
mouseMetaAnalysis@meta.data$study <- str_remove(rownames(mouseMetaAnalysis@meta.data), ".+\\(") %>% str_remove("\\)")
DimPlot(mouseMetaAnalysis, reduction = "umap", group.by = "study")
```

## Visualizing hierarchy of clusters

Another useful analysis to determine the validity of the cell clusters is to visualize the hierarchy of the generated clusters. This could be helpful in further downstream analysis when similar cell types are added to the atlas. Here, the clustree library is used to help visualize the hierarchy of clusters.

```{r hierarchy of clusters, fig.width=15}
mouseMetaAnalysis <- FindClusters(mouseMetaAnalysis, resolution = 1.0, verbose = TRUE)
mouseMetaAnalysis <- FindClusters(mouseMetaAnalysis, resolution = 3.0, verbose = TRUE)
mouseMetaAnalysis <- FindClusters(mouseMetaAnalysis, resolution = 5.0, verbose = TRUE)
mouseMetaAnalysis@meta.data$RNA_snn_res.1000 <- rownames(mouseMetaAnalysis@meta.data)

g <- clustree(mouseMetaAnalysis, 
              layout = "sugiyama",
              use_core_edges = FALSE,
              node_text_size = 2,
              node_alpha = 0,
              edge_width = 1) + 
  scale_edge_alpha(range = c(0.05,0.05)) + # otherwise edges cover everything up
  geom_text(aes(x = 0, y = -10, label = "mouse", size = 2)) # just to make some room so labels aren't cut off

# move the single cell layer of nodes down for more space
gedit <- g$data[, "RNA_snn_res."] == 1000
g$data[gedit, "y"] <- -5

# rotate single cell layer texts
g$layers[[3]]$aes_params$angle <- 90
g
```